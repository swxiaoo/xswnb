<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://xswnb.github.io/xswnb/atom.xml" rel="self"/>
  
  <link href="https://xswnb.github.io/xswnb/"/>
  <updated>2024-02-22T09:05:33.691Z</updated>
  <id>https://xswnb.github.io/xswnb/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AXI协议</title>
    <link href="https://xswnb.github.io/xswnb/2024/02/22/AXI%E5%8D%8F%E8%AE%AE/"/>
    <id>https://xswnb.github.io/xswnb/2024/02/22/AXI%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-02-22T08:15:27.000Z</published>
    <updated>2024-02-22T09:05:33.691Z</updated>
    
    <content type="html"><![CDATA[<p>创建一份图文并茂的AXI协议教程需要详细介绍AXI的核心概念、操作模式、传输类型等。我会以Markdown格式编写，包含基本的AXI介绍、关键特性、主要信号描述，并结合一些简单的WaveDrom图和Mermaid图来直观展示AXI传输的过程。</p><hr><h1 id="AXI协议教程"><a href="#AXI协议教程" class="headerlink" title="AXI协议教程"></a>AXI协议教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>高级外设互连(AXI)是高级微控制器总线架构(AMBA)的一部分，由ARM推出，用于高性能、高带宽、低延迟的片上通信。AXI协议支持高速数据传输，并提供了灵活的连接方式，使其成为了系统级芯片(SoC)设计中的首选协议。</p><h2 id="AXI的关键特性"><a href="#AXI的关键特性" class="headerlink" title="AXI的关键特性"></a>AXI的关键特性</h2><ul><li><strong>高性能</strong>: 支持高频率操作和低延迟接入。</li><li><strong>高带宽</strong>: 多通道设计支持并行数据传输。</li><li><strong>低功耗</strong>: 有效的信号定义减少了功耗。</li><li><strong>灵活性</strong>: 支持各种数据宽度和传输类型，适用于多种应用场景。</li></ul><h2 id="AXI通信模型"><a href="#AXI通信模型" class="headerlink" title="AXI通信模型"></a>AXI通信模型</h2><p>AXI协议定义了五种不同的通道：</p><ol><li><strong>写地址通道 (AW)</strong>: 传输写操作的目的地址信息。</li><li><strong>写数据通道 (W)</strong>: 传输写操作的数据。</li><li><strong>写响应通道 (B)</strong>: 传输写操作的完成状态。</li><li><strong>读地址通道 (AR)</strong>: 传输读操作的目的地址信息。</li><li><strong>读数据通道 (R)</strong>: 传输读操作返回的数据。</li></ol><p>每个通道都有其独立的控制信号，支持并行操作，提高了数据传输的效率。</p><h2 id="AXI主要信号"><a href="#AXI主要信号" class="headerlink" title="AXI主要信号"></a>AXI主要信号</h2><table><thead><tr><th align="center">信号类型</th><th align="center">信号名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">公共</td><td align="center">VALID</td><td align="left">表示当前通道上的数据是有效的</td></tr><tr><td align="center">公共</td><td align="center">READY</td><td align="left">表示目标准备好接收数据</td></tr><tr><td align="center">地址</td><td align="center">ADDR</td><td align="left">传输操作的目标地址</td></tr><tr><td align="center">数据</td><td align="center">DATA</td><td align="left">传输的数据</td></tr><tr><td align="center">控制</td><td align="center">LEN</td><td align="left">传输的长度</td></tr><tr><td align="center">控制</td><td align="center">SIZE</td><td align="left">每次传输的大小</td></tr><tr><td align="center">控制</td><td align="center">BURST</td><td align="left">传输模式</td></tr></tbody></table><h2 id="AXI传输例子"><a href="#AXI传输例子" class="headerlink" title="AXI传输例子"></a>AXI传输例子</h2><p>下面是使用WaveDrom图展示的一个简单的AXI读操作例子：<br><a href="https://wavedrom.com/editor.html">WaveDrom在线编辑</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; signal: [</span><br><span class="line">  &#123; name: &#x27;CLK&#x27;, wave: &#x27;p.....|...&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;ARVALID&#x27;, wave: &#x27;01...0|...&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;ARREADY&#x27;, wave: &#x27;010...|...&#x27;, phase:0.5 &#125;,</span><br><span class="line">  &#123; name: &#x27;RVALID&#x27;, wave: &#x27;0...10|...&#x27;, phase:0.5 &#125;,</span><br><span class="line">  &#123; name: &#x27;RREADY&#x27;, wave: &#x27;01...0|...&#x27; &#125;,</span><br><span class="line">  &#123; name: &#x27;RDATA&#x27;, wave: &#x27;x...=x|...&#x27;, data: [&#x27;Data&#x27;] &#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了一个基本的读操作流程，包括地址阶段和数据阶段的信号变化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AXI协议是设计高性能系统级芯片(SoC)的重要基础。通过了解AXI的关键特性和通信模型，设计者可以有效地构建高效、灵活的通信架构。</p><hr><p>以上是AXI协议的一个基本教程，涵盖了AXI的核心概念和操作示例。你可以根据需要进一步深入了解AXI协议的细节，例如具体的信号定义、传输类型和操作模式等。希望这份教程能帮助你更好地理解和使用AXI协议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建一份图文并茂的AXI协议教程需要详细介绍AXI的核心概念、操作模式、传输类型等。我会以Markdown格式编写，包含基本的AXI介绍、关键特性、主要信号描述，并结合一些简单的WaveDrom图和Mermaid图来直观展示AXI传输的过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="Verilog例程" scheme="https://xswnb.github.io/xswnb/categories/Verilog%E4%BE%8B%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>七人表决器</title>
    <link href="https://xswnb.github.io/xswnb/2024/02/21/%E4%B8%83%E4%BA%BA%E8%A1%A8%E5%86%B3%E5%99%A8/"/>
    <id>https://xswnb.github.io/xswnb/2024/02/21/%E4%B8%83%E4%BA%BA%E8%A1%A8%E5%86%B3%E5%99%A8/</id>
    <published>2024-02-21T12:58:07.000Z</published>
    <updated>2024-02-21T12:58:25.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog中的7人表决器及其测试平台设计教程"><a href="#Verilog中的7人表决器及其测试平台设计教程" class="headerlink" title="Verilog中的7人表决器及其测试平台设计教程"></a>Verilog中的7人表决器及其测试平台设计教程</h1><p>在这篇教程中，我们将通过设计一个7人表决器（Majority Voter）来学习如何使用Verilog语言。7人表决器是一种逻辑电路，它接受7个输入信号，根据多数信号的状态（0或1）决定输出信号的状态。如果输入中有4个或更多的信号为1，则输出为1；否则，输出为0。我们还将编写一个testbench来验证表决器的功能。</p><h2 id="7人表决器设计"><a href="#7人表决器设计" class="headerlink" title="7人表决器设计"></a>7人表决器设计</h2><h3 id="1-定义模块和端口"><a href="#1-定义模块和端口" class="headerlink" title="1. 定义模块和端口"></a>1. 定义模块和端口</h3><p>首先，定义7人表决器的模块和端口。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MajorityVoter(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">6</span>:<span class="number">0</span>] votes, <span class="comment">// 7个输入信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> result <span class="comment">// 输出结果</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-实现表决逻辑"><a href="#2-实现表决逻辑" class="headerlink" title="2. 实现表决逻辑"></a>2. 实现表决逻辑</h3><p>接下来，实现表决器的逻辑，根据输入信号的多数状态决定输出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> result = (votes[<span class="number">0</span>] + votes[<span class="number">1</span>] + votes[<span class="number">2</span>] + votes[<span class="number">3</span>] + votes[<span class="number">4</span>] + votes[<span class="number">5</span>] + votes[<span class="number">6</span>] &gt;= <span class="number">4</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="3-模块结束"><a href="#3-模块结束" class="headerlink" title="3. 模块结束"></a>3. 模块结束</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="测试平台（Testbench）"><a href="#测试平台（Testbench）" class="headerlink" title="测试平台（Testbench）"></a>测试平台（Testbench）</h2><p>为了验证7人表决器的正确性，我们需要编写一个testbench。</p><h3 id="1-定义模块"><a href="#1-定义模块" class="headerlink" title="1. 定义模块"></a>1. 定义模块</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MajorityVoter_tb();</span><br></pre></td></tr></table></figure><h3 id="2-测试信号声明"><a href="#2-测试信号声明" class="headerlink" title="2. 测试信号声明"></a>2. 测试信号声明</h3><p>声明用于测试的信号。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] votes_tb;</span><br><span class="line"><span class="keyword">wire</span> result_tb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化表决器模块</span></span><br><span class="line">MajorityVoter uut(</span><br><span class="line">    <span class="variable">.votes</span>(votes_tb),</span><br><span class="line">    <span class="variable">.result</span>(result_tb)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-测试逻辑"><a href="#3-测试逻辑" class="headerlink" title="3. 测试逻辑"></a>3. 测试逻辑</h3><p>实现测试逻辑，提供不同的输入组合，并观察输出。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    votes_tb = <span class="number">7&#x27;b0000000</span>; #<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试案例1：多数为0</span></span><br><span class="line">    votes_tb = <span class="number">7&#x27;b0000111</span>; #<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试案例2：多数为1</span></span><br><span class="line">    votes_tb = <span class="number">7&#x27;b1111000</span>; #<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试案例3：平票，输出应为0</span></span><br><span class="line">    votes_tb = <span class="number">7&#x27;b1110000</span>; #<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更多测试案例...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试结束</span></span><br><span class="line">    <span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-模块结束"><a href="#4-模块结束" class="headerlink" title="4. 模块结束"></a>4. 模块结束</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，我们学习了如何使用Verilog设计一个7人表决器以及如何为其编写一个testbench来进行验证。这个例子展示了基本的数字逻辑设计和测试方法，是学习数字电路设计和Verilog语言的一个很好的起点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Verilog中的7人表决器及其测试平台设计教程&quot;&gt;&lt;a href=&quot;#Verilog中的7人表决器及其测试平台设计教程&quot; class=&quot;headerlink&quot; title=&quot;Verilog中的7人表决器及其测试平台设计教程&quot;&gt;&lt;/a&gt;Verilog中的7人表决器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pingpong_buffer</title>
    <link href="https://xswnb.github.io/xswnb/2024/02/21/pingpong-buffer/"/>
    <id>https://xswnb.github.io/xswnb/2024/02/21/pingpong-buffer/</id>
    <published>2024-02-21T12:51:33.000Z</published>
    <updated>2024-02-21T12:53:03.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog中的乒乓缓冲区设计教程"><a href="#Verilog中的乒乓缓冲区设计教程" class="headerlink" title="Verilog中的乒乓缓冲区设计教程"></a>Verilog中的乒乓缓冲区设计教程</h1><p>在这篇教程中，我们将通过设计一个乒乓缓冲区来学习如何使用Verilog语言。乒乓缓冲区是一种在硬件设计中常用的技术，用于提高数据处理的效率，特别是在数据流应用中。它涉及到两个缓冲区的使用，一次使用一个，而另一个则在后台准备数据，以此实现无缝数据流。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>我们的目标是设计一个乒乓缓冲区，它可以：</p><ol><li>在一个缓冲区被读取时，另一个缓冲区被填充。</li><li>自动切换当前的活动缓冲区，保证数据的连续流动。</li></ol><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><h3 id="1-定义模块和端口"><a href="#1-定义模块和端口" class="headerlink" title="1. 定义模块和端口"></a>1. 定义模块和端口</h3><p>首先，定义乒乓缓冲区的模块和端口。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> PingPongBuffer(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> write_enable, <span class="comment">// 写使能信号</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in, <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data_out, <span class="comment">// 输出数据</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> buffer_full <span class="comment">// 缓冲区满信号</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-定义内部状态和参数"><a href="#2-定义内部状态和参数" class="headerlink" title="2. 定义内部状态和参数"></a>2. 定义内部状态和参数</h3><p>接下来，定义内部的状态，包括两个缓冲区和一个指示当前活动缓冲区的标志。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] buffer_A[<span class="number">255</span>:<span class="number">0</span>]; <span class="comment">// 缓冲区A</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] buffer_B[<span class="number">255</span>:<span class="number">0</span>]; <span class="comment">// 缓冲区B</span></span><br><span class="line"><span class="keyword">reg</span> buffer_select; <span class="comment">// 缓冲区选择标志，0表示A，1表示B</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] write_ptr; <span class="comment">// 写指针</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] read_ptr; <span class="comment">// 读指针</span></span><br></pre></td></tr></table></figure><h3 id="3-写入逻辑"><a href="#3-写入逻辑" class="headerlink" title="3. 写入逻辑"></a>3. 写入逻辑</h3><p>定义数据写入缓冲区的逻辑。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">        write_ptr &lt;= <span class="number">0</span>;</span><br><span class="line">        buffer_select &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (write_enable) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (buffer_select == <span class="number">0</span>) buffer_A[write_ptr] &lt;= data_in;</span><br><span class="line">        <span class="keyword">else</span> buffer_B[write_ptr] &lt;= data_in;</span><br><span class="line">        </span><br><span class="line">        write_ptr &lt;= write_ptr + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (write_ptr == <span class="number">255</span>) <span class="keyword">begin</span></span><br><span class="line">            buffer_select &lt;= ~buffer_select; <span class="comment">// 切换缓冲区</span></span><br><span class="line">            write_ptr &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-读取逻辑"><a href="#4-读取逻辑" class="headerlink" title="4. 读取逻辑"></a>4. 读取逻辑</h3><p>定义从当前非活动缓冲区读取数据的逻辑。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) read_ptr &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (buffer_select == <span class="number">0</span>) data_out &lt;= buffer_B[read_ptr];</span><br><span class="line">        <span class="keyword">else</span> data_out &lt;= buffer_A[read_ptr];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (read_ptr != write_ptr) read_ptr &lt;= read_ptr + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="5-缓冲区满信号"><a href="#5-缓冲区满信号" class="headerlink" title="5. 缓冲区满信号"></a>5. 缓冲区满信号</h3><p>实现一个简单的缓冲区满信号逻辑。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> buffer_full = (write_ptr == <span class="number">255</span>) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br></pre></td></tr></table></figure><h3 id="6-模块结束"><a href="#6-模块结束" class="headerlink" title="6. 模块结束"></a>6. 模块结束</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，我们学习了如何使用Verilog设计一个乒乓缓冲区。这个例子展示了乒乓缓冲区的基本概念，以及如何使用状态机和条件逻辑来管理两个缓冲区的交替使用。希望这能帮助你在进行数据流管理和优化时有一个好的开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Verilog中的乒乓缓冲区设计教程&quot;&gt;&lt;a href=&quot;#Verilog中的乒乓缓冲区设计教程&quot; class=&quot;headerlink&quot; title=&quot;Verilog中的乒乓缓冲区设计教程&quot;&gt;&lt;/a&gt;Verilog中的乒乓缓冲区设计教程&lt;/h1&gt;&lt;p&gt;在这篇教程中</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>奇偶校验</title>
    <link href="https://xswnb.github.io/xswnb/2024/02/21/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/"/>
    <id>https://xswnb.github.io/xswnb/2024/02/21/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/</id>
    <published>2024-02-21T12:46:28.000Z</published>
    <updated>2024-02-21T12:53:33.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog中的奇偶校验生成器和检测器设计教程"><a href="#Verilog中的奇偶校验生成器和检测器设计教程" class="headerlink" title="Verilog中的奇偶校验生成器和检测器设计教程"></a>Verilog中的奇偶校验生成器和检测器设计教程</h1><p>在这篇教程中，我们将通过设计一个奇偶校验生成器和检测器来学习如何使用Verilog语言。奇偶校验是一种简单的错误检测技术，常用于通信系统中，以确保数据的完整性。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>我们的目标是设计两个模块：</p><ol><li><strong>奇偶校验生成器</strong> - 输入一串数据位，输出一个附加的奇偶校验位。</li><li><strong>奇偶校验检测器</strong> - 输入一串数据位和一个奇偶校验位，检测是否有错误（即数据位加校验位的总和是否为奇数或偶数）。</li></ol><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><h3 id="奇偶校验生成器"><a href="#奇偶校验生成器" class="headerlink" title="奇偶校验生成器"></a>奇偶校验生成器</h3><h4 id="1-定义模块和端口"><a href="#1-定义模块和端口" class="headerlink" title="1. 定义模块和端口"></a>1. 定义模块和端口</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ParityGenerator(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data, <span class="comment">// 8位数据输入</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> parityType, <span class="comment">// 奇偶校验类型选择，0为偶校验，1为奇校验</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> parityBit <span class="comment">// 生成的奇偶校验位</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-生成奇偶校验位逻辑"><a href="#2-生成奇偶校验位逻辑" class="headerlink" title="2. 生成奇偶校验位逻辑"></a>2. 生成奇偶校验位逻辑</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> parityBit = (parityType == <span class="number">0</span>) ? ~^data : ^data;</span><br></pre></td></tr></table></figure><p>这行代码使用了Verilog的按位异或约简操作符<code>^</code>，以及条件运算符。对于偶校验，我们对数据位进行异或运算，并取反结果；对于奇校验，直接进行异或运算。</p><h4 id="3-模块结束"><a href="#3-模块结束" class="headerlink" title="3. 模块结束"></a>3. 模块结束</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="奇偶校验检测器"><a href="#奇偶校验检测器" class="headerlink" title="奇偶校验检测器"></a>奇偶校验检测器</h3><h4 id="1-定义模块和端口-1"><a href="#1-定义模块和端口-1" class="headerlink" title="1. 定义模块和端口"></a>1. 定义模块和端口</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ParityChecker(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data, <span class="comment">// 8位数据输入</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> parityBit, <span class="comment">// 接收的奇偶校验位</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> error <span class="comment">// 错误标志，1表示检测到错误</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-检测逻辑"><a href="#2-检测逻辑" class="headerlink" title="2. 检测逻辑"></a>2. 检测逻辑</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> error = ^data ^ parityBit;</span><br></pre></td></tr></table></figure><p>这行代码同样使用了按位异或约简操作符<code>^</code>。它将数据位和校验位一起进行异或运算。如果总和为1，表示有奇数个1，即检测到错误。</p><h4 id="3-模块结束-1"><a href="#3-模块结束-1" class="headerlink" title="3. 模块结束"></a>3. 模块结束</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，我们学习了如何使用Verilog设计奇偶校验生成器和检测器。这个例子展示了Verilog的基本语法，以及如何使用逻辑操作符来实现简单的数字逻辑功能。希望这能帮助你在使用Verilog进行数字设计时有一个好的开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Verilog中的奇偶校验生成器和检测器设计教程&quot;&gt;&lt;a href=&quot;#Verilog中的奇偶校验生成器和检测器设计教程&quot; class=&quot;headerlink&quot; title=&quot;Verilog中的奇偶校验生成器和检测器设计教程&quot;&gt;&lt;/a&gt;Verilog中的奇偶校验生</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FSM售卖机</title>
    <link href="https://xswnb.github.io/xswnb/2024/02/21/FSM%E5%94%AE%E5%8D%96%E6%9C%BA/"/>
    <id>https://xswnb.github.io/xswnb/2024/02/21/FSM%E5%94%AE%E5%8D%96%E6%9C%BA/</id>
    <published>2024-02-21T09:48:23.000Z</published>
    <updated>2024-02-21T09:52:34.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Verilog中的自动售卖机FSM设计教程"><a href="#Verilog中的自动售卖机FSM设计教程" class="headerlink" title="Verilog中的自动售卖机FSM设计教程"></a>Verilog中的自动售卖机FSM设计教程</h1><p>在这篇教程中，我们将通过设计一个简单的自动售卖机来学习如何使用Verilog语言实现有限状态机（FSM）。自动售卖机将接受两种硬币：5元和10元，以售卖一个15元的商品为例。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>我们的目标是设计一个FSM，它可以：</p><ul><li>接受5元和10元两种输入</li><li>当累计金额达到商品价格15元时，释放商品</li><li>如果投入超过商品价格，计算并返回找零</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><h3 id="1-定义状态"><a href="#1-定义状态" class="headerlink" title="1. 定义状态"></a>1. 定义状态</h3><p>首先，我们需要定义FSM的所有可能状态。对于自动售卖机，我们可以设定以下状态：</p><ul><li><code>S0</code>：初始状态（无钱）</li><li><code>S5</code>：已接收5元</li><li><code>S10</code>：已接收10元</li><li><code>S15</code>：已累计15元，准备释放商品并返回初始状态</li></ul><h3 id="2-定义输入"><a href="#2-定义输入" class="headerlink" title="2. 定义输入"></a>2. 定义输入</h3><p>我们的自动售卖机接受两种输入：</p><ul><li><code>coin5</code>：投入5元</li><li><code>coin10</code>：投入10元</li></ul><h3 id="3-状态转移和输出逻辑"><a href="#3-状态转移和输出逻辑" class="headerlink" title="3. 状态转移和输出逻辑"></a>3. 状态转移和输出逻辑</h3><p>接下来，我们需要定义在各种输入下，从一个状态到另一个状态的转移，以及相应的输出行为。</p><h3 id="4-Verilog代码实现"><a href="#4-Verilog代码实现" class="headerlink" title="4. Verilog代码实现"></a>4. Verilog代码实现</h3><h4 id="定义模块和端口"><a href="#定义模块和端口" class="headerlink" title="定义模块和端口"></a>定义模块和端口</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> VendingMachineFSM(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> reset,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> coin5,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> coin10,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> <span class="keyword">release</span>,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] change</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态和参数定义</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] state;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] next_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> S0 = <span class="number">2&#x27;b00</span>, S5 = <span class="number">2&#x27;b01</span>, S10 = <span class="number">2&#x27;b10</span>, S15 = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移逻辑</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= next_state;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下一个状态和输出的决定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        S0: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (coin5) next_state = S5;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (coin10) next_state = S10;</span><br><span class="line">            <span class="keyword">else</span> next_state = S0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        S5: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (coin5) next_state = S10;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (coin10) next_state = S15;</span><br><span class="line">            <span class="keyword">else</span> next_state = S5;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        S10: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (coin5) next_state = S15;</span><br><span class="line">            <span class="keyword">else</span> next_state = S10;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        S15: <span class="keyword">begin</span></span><br><span class="line">            next_state = S0; <span class="comment">// 商品释放后返回初始状态</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: next_state = S0;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//控制输出</span></span><br><span class="line"><span class="keyword">always</span> @(state) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (state)</span><br><span class="line">        S15: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">release</span> = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            change = <span class="number">0</span>; <span class="comment">// 假设顾客投入金额恰好</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">release</span> = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            change = <span class="number">0</span>; <span class="comment">// 无需找零</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，我们学习了如何使用Verilog设计一个简单的自动售卖机FSM。这个例子展示了FSM的基本概念，状态定义，以及状态转移逻辑的实现方法。希望这能帮助你在使用Verilog进行数字设计时有一个好的开始。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Verilog中的自动售卖机FSM设计教程&quot;&gt;&lt;a href=&quot;#Verilog中的自动售卖机FSM设计教程&quot; class=&quot;headerlink&quot; title=&quot;Verilog中的自动售卖机FSM设计教程&quot;&gt;&lt;/a&gt;Verilog中的自动售卖机FSM设计教程&lt;/</summary>
      
    
    
    
    
  </entry>
  
</feed>
