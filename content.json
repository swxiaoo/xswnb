{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://xswnb.github.io/xswnb","root":"/xswnb/"},"pages":[],"posts":[{"title":"FSM售卖机","slug":"verilog例程/FSM售卖机","date":"2024-02-21T09:48:23.000Z","updated":"2024-02-21T09:52:34.489Z","comments":true,"path":"2024/02/21/verilog例程/FSM售卖机/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/verilog%E4%BE%8B%E7%A8%8B/FSM%E5%94%AE%E5%8D%96%E6%9C%BA/","excerpt":"","text":"Verilog中的自动售卖机FSM设计教程在这篇教程中，我们将通过设计一个简单的自动售卖机来学习如何使用Verilog语言实现有限状态机（FSM）。自动售卖机将接受两种硬币：5元和10元，以售卖一个15元的商品为例。 设计目标我们的目标是设计一个FSM，它可以： 接受5元和10元两种输入 当累计金额达到商品价格15元时，释放商品 如果投入超过商品价格，计算并返回找零 设计步骤1. 定义状态首先，我们需要定义FSM的所有可能状态。对于自动售卖机，我们可以设定以下状态： S0：初始状态（无钱） S5：已接收5元 S10：已接收10元 S15：已累计15元，准备释放商品并返回初始状态 2. 定义输入我们的自动售卖机接受两种输入： coin5：投入5元 coin10：投入10元 3. 状态转移和输出逻辑接下来，我们需要定义在各种输入下，从一个状态到另一个状态的转移，以及相应的输出行为。 4. Verilog代码实现定义模块和端口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960module VendingMachineFSM( input wire clk, input wire reset, input wire coin5, input wire coin10, output reg release, output reg [1:0] change);//状态和参数定义reg [1:0] state;reg [1:0] next_state;parameter S0 = 2&#x27;b00, S5 = 2&#x27;b01, S10 = 2&#x27;b10, S15 = 2&#x27;b11;//状态转移逻辑always @(posedge clk or posedge reset) begin if (reset) state &lt;= S0; else state &lt;= next_state;end//下一个状态和输出的决定always @(*) begin case (state) S0: begin if (coin5) next_state = S5; else if (coin10) next_state = S10; else next_state = S0; end S5: begin if (coin5) next_state = S10; else if (coin10) next_state = S15; else next_state = S5; end S10: begin if (coin5) next_state = S15; else next_state = S10; end S15: begin next_state = S0; // 商品释放后返回初始状态 end default: next_state = S0; endcaseend//控制输出always @(state) begin case (state) S15: begin release = 1&#x27;b1; change = 0; // 假设顾客投入金额恰好 end default: begin release = 1&#x27;b0; change = 0; // 无需找零 end endcaseendendmodule 总结通过本教程，我们学习了如何使用Verilog设计一个简单的自动售卖机FSM。这个例子展示了FSM的基本概念，状态定义，以及状态转移逻辑的实现方法。希望这能帮助你在使用Verilog进行数字设计时有一个好的开始。","categories":[],"tags":[]},{"title":"DVP接口","slug":"技术学习/DVP接口","date":"2024-02-21T09:25:41.000Z","updated":"2024-02-21T09:28:50.758Z","comments":true,"path":"2024/02/21/技术学习/DVP接口/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/DVP%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"sensor接口之DVP [什么是DVP] [DVP时序] [PCLK、HSYNC、VSYNC对应关系] [sensor并行输出说明] [实际测量DVP信号] 什么是DVPDVP（Digital Video Port） 是传统的sensor输出接口，采用并行输出方式，d数据位宽有8bit、10bit、12bit、16bit，是CMOS电平信号（重点是非差分信号），PCLK最大速率为96MHz，接口如下图： DVP接口 PCLK：pixel clock ,像素时钟，每个时钟对应一个像素数据； HSYNC：horizonal synchronization，行同步信号 VSYNC：vertical synchronization，帧同步信号； DATA：像素数据，视频数据，具体位宽要看ISP是否支持； XCLK：或者MCLK，ISP芯片输出给驱动sensor的时钟； SCL，SDA：IIC用来读写sensor的寄存器，配置sensor。 DVP时序PCLK、HSYNC、VSYNC对应关系ISP与sensor通过DVP接口连接，ISP首先会给sensor一个XCLK，sensor内部的PLL会对计算，产生PCLK，PCLK由幅面（F_W、F_H）、帧率（FPS）决定，并存在如下关系： PCLK &#x3D; F_W * F_H * FPS 以F_W &#x3D; 3556，F_H &#x3D; 1125，A_W &#x3D; 1920， A_H &#x3D; 1080，FPS &#x3D; 25（1080P25）为例，说明几个对应关系： DVP时许 注意：上图中标有错误，对照下文说明可以找出错误 PCLK是一个像素传输的时间，所以HSYNC时间是PCLK的3556倍； 在这3556个像素中，只有1920个像素是有效的（A_W大小），在剩下的1636个像素点时间内sensor是不传输数据的； VSYNC是帧同步信号，所以VSYNC时间是PCLK的3556*1125倍； 同样只有在1920*1080个有效像素时间内，sensor在传输数据； sensor并行输出说明 DVP并行输出 图中有12bit通道传输像素数据，但有些ISP芯片只能接受并行输入，会丢弃sensor端输出的低两位，这会造成低照条件下，颜色之间过度明显。 实际测量DVP信号 XCLK XCLK PCLK PCLK HSYNC HSYNC VSYNC VSYNC SCL SCL 视频帧同步头波形 视频帧同步 多波形图 多信号","categories":[],"tags":[]}],"categories":[],"tags":[]}