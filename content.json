{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://xswnb.github.io/xswnb","root":"/xswnb/"},"pages":[],"posts":[{"title":"AXI协议","slug":"技术学习/AXI协议","date":"2024-02-22T08:15:27.000Z","updated":"2024-02-22T08:18:59.904Z","comments":true,"path":"2024/02/22/技术学习/AXI协议/","permalink":"https://xswnb.github.io/xswnb/2024/02/22/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/AXI%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"创建一份图文并茂的AXI协议教程需要详细介绍AXI的核心概念、操作模式、传输类型等。我会以Markdown格式编写，包含基本的AXI介绍、关键特性、主要信号描述，并结合一些简单的WaveDrom图和Mermaid图来直观展示AXI传输的过程。 AXI协议教程简介高级外设互连(AXI)是高级微控制器总线架构(AMBA)的一部分，由ARM推出，用于高性能、高带宽、低延迟的片上通信。AXI协议支持高速数据传输，并提供了灵活的连接方式，使其成为了系统级芯片(SoC)设计中的首选协议。 AXI的关键特性 高性能: 支持高频率操作和低延迟接入。 高带宽: 多通道设计支持并行数据传输。 低功耗: 有效的信号定义减少了功耗。 灵活性: 支持各种数据宽度和传输类型，适用于多种应用场景。 AXI通信模型AXI协议定义了五种不同的通道： 写地址通道 (AW): 传输写操作的目的地址信息。 写数据通道 (W): 传输写操作的数据。 写响应通道 (B): 传输写操作的完成状态。 读地址通道 (AR): 传输读操作的目的地址信息。 读数据通道 (R): 传输读操作返回的数据。 每个通道都有其独立的控制信号，支持并行操作，提高了数据传输的效率。 AXI主要信号 信号类型 信号名称 描述 公共 VALID 表示当前通道上的数据是有效的 公共 READY 表示目标准备好接收数据 地址 ADDR 传输操作的目标地址 数据 DATA 传输的数据 控制 LEN 传输的长度 控制 SIZE 每次传输的大小 控制 BURST 传输模式 AXI传输例子下面是使用WaveDrom图展示的一个简单的AXI读操作例子：WaveDrom在线编辑 12345678&#123; signal: [ &#123; name: &#x27;CLK&#x27;, wave: &#x27;p.....|...&#x27; &#125;, &#123; name: &#x27;ARVALID&#x27;, wave: &#x27;01...0|...&#x27; &#125;, &#123; name: &#x27;ARREADY&#x27;, wave: &#x27;010...|...&#x27;, phase:0.5 &#125;, &#123; name: &#x27;RVALID&#x27;, wave: &#x27;0...10|...&#x27;, phase:0.5 &#125;, &#123; name: &#x27;RREADY&#x27;, wave: &#x27;01...0|...&#x27; &#125;, &#123; name: &#x27;RDATA&#x27;, wave: &#x27;x...=x|...&#x27;, data: [&#x27;Data&#x27;] &#125;]&#125; 这个例子展示了一个基本的读操作流程，包括地址阶段和数据阶段的信号变化。 总结AXI协议是设计高性能系统级芯片(SoC)的重要基础。通过了解AXI的关键特性和通信模型，设计者可以有效地构建高效、灵活的通信架构。 以上是AXI协议的一个基本教程，涵盖了AXI的核心概念和操作示例。你可以根据需要进一步深入了解AXI协议的细节，例如具体的信号定义、传输类型和操作模式等。希望这份教程能帮助你更好地理解和使用AXI协议。","categories":[],"tags":[]},{"title":"七人表决器","slug":"verilog例程/七人表决器","date":"2024-02-21T12:58:07.000Z","updated":"2024-02-21T12:58:25.064Z","comments":true,"path":"2024/02/21/verilog例程/七人表决器/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/verilog%E4%BE%8B%E7%A8%8B/%E4%B8%83%E4%BA%BA%E8%A1%A8%E5%86%B3%E5%99%A8/","excerpt":"","text":"Verilog中的7人表决器及其测试平台设计教程在这篇教程中，我们将通过设计一个7人表决器（Majority Voter）来学习如何使用Verilog语言。7人表决器是一种逻辑电路，它接受7个输入信号，根据多数信号的状态（0或1）决定输出信号的状态。如果输入中有4个或更多的信号为1，则输出为1；否则，输出为0。我们还将编写一个testbench来验证表决器的功能。 7人表决器设计1. 定义模块和端口首先，定义7人表决器的模块和端口。 1234module MajorityVoter( input wire [6:0] votes, // 7个输入信号 output wire result // 输出结果); 2. 实现表决逻辑接下来，实现表决器的逻辑，根据输入信号的多数状态决定输出。 1assign result = (votes[0] + votes[1] + votes[2] + votes[3] + votes[4] + votes[5] + votes[6] &gt;= 4) ? 1&#x27;b1 : 1&#x27;b0; 3. 模块结束1endmodule 测试平台（Testbench）为了验证7人表决器的正确性，我们需要编写一个testbench。 1. 定义模块1module MajorityVoter_tb(); 2. 测试信号声明声明用于测试的信号。 12345678reg [6:0] votes_tb;wire result_tb;// 实例化表决器模块MajorityVoter uut( .votes(votes_tb), .result(result_tb)); 3. 测试逻辑实现测试逻辑，提供不同的输入组合，并观察输出。 123456789101112131415161718initial begin // 初始化 votes_tb = 7&#x27;b0000000; #10; // 测试案例1：多数为0 votes_tb = 7&#x27;b0000111; #10; // 测试案例2：多数为1 votes_tb = 7&#x27;b1111000; #10; // 测试案例3：平票，输出应为0 votes_tb = 7&#x27;b1110000; #10; // 更多测试案例... // 测试结束 $finish;end 4. 模块结束1endmodule 总结通过本教程，我们学习了如何使用Verilog设计一个7人表决器以及如何为其编写一个testbench来进行验证。这个例子展示了基本的数字逻辑设计和测试方法，是学习数字电路设计和Verilog语言的一个很好的起点。","categories":[],"tags":[]},{"title":"pingpong_buffer","slug":"verilog例程/pingpong-buffer","date":"2024-02-21T12:51:33.000Z","updated":"2024-02-21T12:53:03.744Z","comments":true,"path":"2024/02/21/verilog例程/pingpong-buffer/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/verilog%E4%BE%8B%E7%A8%8B/pingpong-buffer/","excerpt":"","text":"Verilog中的乒乓缓冲区设计教程在这篇教程中，我们将通过设计一个乒乓缓冲区来学习如何使用Verilog语言。乒乓缓冲区是一种在硬件设计中常用的技术，用于提高数据处理的效率，特别是在数据流应用中。它涉及到两个缓冲区的使用，一次使用一个，而另一个则在后台准备数据，以此实现无缝数据流。 设计目标我们的目标是设计一个乒乓缓冲区，它可以： 在一个缓冲区被读取时，另一个缓冲区被填充。 自动切换当前的活动缓冲区，保证数据的连续流动。 设计步骤1. 定义模块和端口首先，定义乒乓缓冲区的模块和端口。 12345678module PingPongBuffer( input wire clk, input wire reset, input wire write_enable, // 写使能信号 input wire [7:0] data_in, // 输入数据 output reg [7:0] data_out, // 输出数据 output wire buffer_full // 缓冲区满信号); 2. 定义内部状态和参数接下来，定义内部的状态，包括两个缓冲区和一个指示当前活动缓冲区的标志。 12345reg [7:0] buffer_A[255:0]; // 缓冲区Areg [7:0] buffer_B[255:0]; // 缓冲区Breg buffer_select; // 缓冲区选择标志，0表示A，1表示Breg [7:0] write_ptr; // 写指针reg [7:0] read_ptr; // 读指针 3. 写入逻辑定义数据写入缓冲区的逻辑。 1234567891011121314151617always @(posedge clk) begin if (reset) begin write_ptr &lt;= 0; buffer_select &lt;= 0; end else if (write_enable) begin if (buffer_select == 0) buffer_A[write_ptr] &lt;= data_in; else buffer_B[write_ptr] &lt;= data_in; write_ptr &lt;= write_ptr + 1; if (write_ptr == 255) begin buffer_select &lt;= ~buffer_select; // 切换缓冲区 write_ptr &lt;= 0; end endend 4. 读取逻辑定义从当前非活动缓冲区读取数据的逻辑。 123456789always @(posedge clk) begin if (reset) read_ptr &lt;= 0; else begin if (buffer_select == 0) data_out &lt;= buffer_B[read_ptr]; else data_out &lt;= buffer_A[read_ptr]; if (read_ptr != write_ptr) read_ptr &lt;= read_ptr + 1; endend 5. 缓冲区满信号实现一个简单的缓冲区满信号逻辑。 1assign buffer_full = (write_ptr == 255) ? 1&#x27;b1 : 1&#x27;b0; 6. 模块结束1endmodule 总结通过本教程，我们学习了如何使用Verilog设计一个乒乓缓冲区。这个例子展示了乒乓缓冲区的基本概念，以及如何使用状态机和条件逻辑来管理两个缓冲区的交替使用。希望这能帮助你在进行数据流管理和优化时有一个好的开始。","categories":[],"tags":[]},{"title":"奇偶校验","slug":"verilog例程/奇偶校验","date":"2024-02-21T12:46:28.000Z","updated":"2024-02-21T12:53:33.810Z","comments":true,"path":"2024/02/21/verilog例程/奇偶校验/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/verilog%E4%BE%8B%E7%A8%8B/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"Verilog中的奇偶校验生成器和检测器设计教程在这篇教程中，我们将通过设计一个奇偶校验生成器和检测器来学习如何使用Verilog语言。奇偶校验是一种简单的错误检测技术，常用于通信系统中，以确保数据的完整性。 设计目标我们的目标是设计两个模块： 奇偶校验生成器 - 输入一串数据位，输出一个附加的奇偶校验位。 奇偶校验检测器 - 输入一串数据位和一个奇偶校验位，检测是否有错误（即数据位加校验位的总和是否为奇数或偶数）。 设计步骤奇偶校验生成器1. 定义模块和端口12345module ParityGenerator( input wire [7:0] data, // 8位数据输入 input wire parityType, // 奇偶校验类型选择，0为偶校验，1为奇校验 output wire parityBit // 生成的奇偶校验位); 2. 生成奇偶校验位逻辑1assign parityBit = (parityType == 0) ? ~^data : ^data; 这行代码使用了Verilog的按位异或约简操作符^，以及条件运算符。对于偶校验，我们对数据位进行异或运算，并取反结果；对于奇校验，直接进行异或运算。 3. 模块结束1endmodule 奇偶校验检测器1. 定义模块和端口12345module ParityChecker( input wire [7:0] data, // 8位数据输入 input wire parityBit, // 接收的奇偶校验位 output wire error // 错误标志，1表示检测到错误); 2. 检测逻辑1assign error = ^data ^ parityBit; 这行代码同样使用了按位异或约简操作符^。它将数据位和校验位一起进行异或运算。如果总和为1，表示有奇数个1，即检测到错误。 3. 模块结束1endmodule 总结通过本教程，我们学习了如何使用Verilog设计奇偶校验生成器和检测器。这个例子展示了Verilog的基本语法，以及如何使用逻辑操作符来实现简单的数字逻辑功能。希望这能帮助你在使用Verilog进行数字设计时有一个好的开始。","categories":[],"tags":[]},{"title":"FSM售卖机","slug":"verilog例程/FSM售卖机","date":"2024-02-21T09:48:23.000Z","updated":"2024-02-21T09:52:34.489Z","comments":true,"path":"2024/02/21/verilog例程/FSM售卖机/","permalink":"https://xswnb.github.io/xswnb/2024/02/21/verilog%E4%BE%8B%E7%A8%8B/FSM%E5%94%AE%E5%8D%96%E6%9C%BA/","excerpt":"","text":"Verilog中的自动售卖机FSM设计教程在这篇教程中，我们将通过设计一个简单的自动售卖机来学习如何使用Verilog语言实现有限状态机（FSM）。自动售卖机将接受两种硬币：5元和10元，以售卖一个15元的商品为例。 设计目标我们的目标是设计一个FSM，它可以： 接受5元和10元两种输入 当累计金额达到商品价格15元时，释放商品 如果投入超过商品价格，计算并返回找零 设计步骤1. 定义状态首先，我们需要定义FSM的所有可能状态。对于自动售卖机，我们可以设定以下状态： S0：初始状态（无钱） S5：已接收5元 S10：已接收10元 S15：已累计15元，准备释放商品并返回初始状态 2. 定义输入我们的自动售卖机接受两种输入： coin5：投入5元 coin10：投入10元 3. 状态转移和输出逻辑接下来，我们需要定义在各种输入下，从一个状态到另一个状态的转移，以及相应的输出行为。 4. Verilog代码实现定义模块和端口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960module VendingMachineFSM( input wire clk, input wire reset, input wire coin5, input wire coin10, output reg release, output reg [1:0] change);//状态和参数定义reg [1:0] state;reg [1:0] next_state;parameter S0 = 2&#x27;b00, S5 = 2&#x27;b01, S10 = 2&#x27;b10, S15 = 2&#x27;b11;//状态转移逻辑always @(posedge clk or posedge reset) begin if (reset) state &lt;= S0; else state &lt;= next_state;end//下一个状态和输出的决定always @(*) begin case (state) S0: begin if (coin5) next_state = S5; else if (coin10) next_state = S10; else next_state = S0; end S5: begin if (coin5) next_state = S10; else if (coin10) next_state = S15; else next_state = S5; end S10: begin if (coin5) next_state = S15; else next_state = S10; end S15: begin next_state = S0; // 商品释放后返回初始状态 end default: next_state = S0; endcaseend//控制输出always @(state) begin case (state) S15: begin release = 1&#x27;b1; change = 0; // 假设顾客投入金额恰好 end default: begin release = 1&#x27;b0; change = 0; // 无需找零 end endcaseendendmodule 总结通过本教程，我们学习了如何使用Verilog设计一个简单的自动售卖机FSM。这个例子展示了FSM的基本概念，状态定义，以及状态转移逻辑的实现方法。希望这能帮助你在使用Verilog进行数字设计时有一个好的开始。","categories":[],"tags":[]}],"categories":[],"tags":[]}